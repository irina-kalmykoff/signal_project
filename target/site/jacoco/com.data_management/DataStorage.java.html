<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="nl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cardio_generator</a> &gt; <a href="index.source.html" class="el_package">com.data_management</a> &gt; <span class="el_source">DataStorage.java</span></div><h1>DataStorage.java</h1><pre class="source lang-java linenums">package com.data_management;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.atomic.AtomicLong;
import com.alerts.AlertGenerator;

/**
 * Manages storage and retrieval of patient data within a healthcare monitoring
 * system with support for real-time data integration.
 * This class serves as a repository for all patient records, organized by
 * patient IDs, with thread-safe operations for concurrent data updates.
 */
public class DataStorage {
    // Thread-safe map to store patient objects indexed by their unique patient ID
    private final Map&lt;Integer, Patient&gt; patientMap;
    
    // Read-write locks for each patient to allow concurrent reads while ensuring exclusive writes
    private final Map&lt;Integer, ReadWriteLock&gt; patientLocks;
    
    // Counter for tracking total number of records processed
    private final AtomicLong totalRecordsProcessed;
    
    // Cache for frequently accessed patient records (last 1000 records per patient)
    private final Map&lt;Integer, List&lt;PatientRecord&gt;&gt; recentRecordsCache;
    private static final int CACHE_SIZE = 1000;

    /**
     * Constructs a new instance of EnhancedDataStorage, initializing the underlying storage
     * structure with thread-safe collections for real-time data handling.
    */
<span class="fc" id="L37">    public DataStorage() {</span>
<span class="fc" id="L38">        this.patientMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L39">        this.patientLocks = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L40">        this.totalRecordsProcessed = new AtomicLong(0);</span>
<span class="fc" id="L41">        this.recentRecordsCache = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L42">    }</span>

    /**
     * Adds or updates patient data in the storage with thread-safe operations.
     * If the patient does not exist, a new Patient object is created and added to
     * the storage. This method is optimized for concurrent access in real-time scenarios.
     *
     * @param patientId        the unique identifier of the patient
     * @param measurementValue the value of the health metric being recorded
     * @param recordType       the type of record, e.g., &quot;HeartRate&quot;, &quot;BloodPressure&quot;
     * @param timestamp        the time at which the measurement was taken, in
     *                         milliseconds since the Unix epoch
     */
    public void addPatientData(int patientId, double measurementValue, String recordType, long timestamp) {
        // Validate input parameters
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (patientId &lt; 0) {</span>
<span class="nc" id="L58">            System.err.println(&quot;Invalid patient ID (negative): &quot; + patientId + &quot; - skipping record&quot;);</span>
<span class="nc" id="L59">            return;</span>
        }
        
<span class="pc bpc" id="L62" title="2 of 4 branches missed.">        if (recordType == null || recordType.trim().isEmpty()) {</span>
<span class="nc" id="L63">            System.err.println(&quot;Invalid record type (null or empty) for patient &quot; + patientId + &quot; - skipping record&quot;);</span>
<span class="nc" id="L64">            return;</span>
        }
        
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (timestamp &lt; 0) {</span>
<span class="nc" id="L68">            System.err.println(&quot;Invalid timestamp (negative) for patient &quot; + patientId + &quot; - skipping record&quot;);</span>
<span class="nc" id="L69">            return;</span>
        }

        // Get or create patient with thread-safe operations
<span class="fc" id="L73">        Patient patient = patientMap.computeIfAbsent(patientId, id -&gt; {</span>
<span class="fc" id="L74">            patientLocks.put(id, new ReentrantReadWriteLock());</span>
<span class="fc" id="L75">            recentRecordsCache.put(id, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L76">            return new Patient(id);</span>
        });

        // Get the lock for this specific patient
<span class="pc" id="L80">        ReadWriteLock lock = patientLocks.computeIfAbsent(patientId, id -&gt; new ReentrantReadWriteLock());</span>
        
        // Acquire write lock for adding data
<span class="fc" id="L83">        lock.writeLock().lock();</span>
        try {
            // Check for duplicate records (same patient, type, and timestamp)
<span class="fc bfc" id="L86" title="All 2 branches covered.">            if (!isDuplicateRecord(patientId, recordType, timestamp)) {</span>
                // Add the record to the patient
<span class="fc" id="L88">                patient.addRecord(measurementValue, recordType, timestamp);</span>
                
                // Update the recent records cache
<span class="fc" id="L91">                updateRecentRecordsCache(patientId, measurementValue, recordType, timestamp);</span>
                
                // Increment the total records counter
<span class="fc" id="L94">                totalRecordsProcessed.incrementAndGet();</span>
                
                // Log successful data addition for monitoring
<span class="fc bfc" id="L97" title="All 2 branches covered.">                if (totalRecordsProcessed.get() % 1000 == 0) {</span>
<span class="fc" id="L98">                    System.out.println(&quot;Processed &quot; + totalRecordsProcessed.get() + &quot; total records&quot;);</span>
                }
            } else {
<span class="fc" id="L101">                System.out.println(&quot;Duplicate record detected for patient &quot; + patientId + </span>
                                 &quot;, type: &quot; + recordType + &quot;, timestamp: &quot; + timestamp + &quot; - skipping&quot;);
            }
        } finally {
<span class="fc" id="L105">            lock.writeLock().unlock();</span>
        }
<span class="fc" id="L107">    }</span>

    /**
     * Checks if a record with the same patient ID, record type, and timestamp already exists.
     * This helps prevent duplicate data insertion during real-time streaming.
     *
     * @param patientId  the patient ID
     * @param recordType the type of record
     * @param timestamp  the timestamp of the record
     * @return true if a duplicate record exists, false otherwise
     */
    private boolean isDuplicateRecord(int patientId, String recordType, long timestamp) {
<span class="fc" id="L119">        List&lt;PatientRecord&gt; recentRecords = recentRecordsCache.get(patientId);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (recentRecords == null) {</span>
<span class="nc" id="L121">            return false;</span>
        }
        
        // Check the last few records for duplicates (more efficient than checking all records)
<span class="fc" id="L125">        int startIndex = Math.max(0, recentRecords.size() - 10); // Check last 10 records</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        for (int i = startIndex; i &lt; recentRecords.size(); i++) {</span>
<span class="fc" id="L127">            PatientRecord record = recentRecords.get(i);</span>
<span class="fc bfc" id="L128" title="All 4 branches covered.">            if (record.getRecordType().equals(recordType) &amp;&amp; record.getTimestamp() == timestamp) {</span>
<span class="fc" id="L129">                return true;</span>
            }
        }
<span class="fc" id="L132">        return false;</span>
    }

    /**
     * Updates the recent records cache for efficient duplicate detection and quick access.
     *
     * @param patientId        the patient ID
     * @param measurementValue the measurement value
     * @param recordType       the record type
     * @param timestamp        the timestamp
     */
    private void updateRecentRecordsCache(int patientId, double measurementValue, String recordType, long timestamp) {
<span class="fc" id="L144">        List&lt;PatientRecord&gt; recentRecords = recentRecordsCache.get(patientId);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (recentRecords != null) {</span>
<span class="fc" id="L146">            PatientRecord newRecord = new PatientRecord(patientId, measurementValue, recordType, timestamp);</span>
<span class="fc" id="L147">            recentRecords.add(newRecord);</span>
            
            // Maintain cache size limit
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (recentRecords.size() &gt; CACHE_SIZE) {</span>
<span class="fc" id="L151">                recentRecords.remove(0); // Remove oldest record</span>
            }
        }
<span class="fc" id="L154">    }</span>

    /**
     * Retrieves a list of PatientRecord objects for a specific patient, filtered by
     * a time range with thread-safe read operations.
     *
     * @param patientId the unique identifier of the patient whose records are to be
     *                  retrieved
     * @param startTime the start of the time range, in milliseconds since the Unix
     *                  epoch
     * @param endTime   the end of the time range, in milliseconds since the Unix
     *                  epoch
     * @return a list of PatientRecord objects that fall within the specified time
     *         range
     */
    public List&lt;PatientRecord&gt; getRecords(int patientId, long startTime, long endTime) {
<span class="fc" id="L170">        Patient patient = patientMap.get(patientId);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (patient == null) {</span>
<span class="fc" id="L172">            return new ArrayList&lt;&gt;(); // return an empty list if no patient is found</span>
        }

<span class="fc" id="L175">        ReadWriteLock lock = patientLocks.get(patientId);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (lock == null) {</span>
<span class="nc" id="L177">            return new ArrayList&lt;&gt;();</span>
        }

        // Acquire read lock for thread-safe access
<span class="fc" id="L181">        lock.readLock().lock();</span>
        try {
<span class="fc" id="L183">            return patient.getRecords(startTime, endTime);</span>
        } finally {
<span class="fc" id="L185">            lock.readLock().unlock();</span>
        }
    }

    /**
     * Retrieves the most recent records for a patient (useful for real-time monitoring).
     *
     * @param patientId the unique identifier of the patient
     * @param count     the maximum number of recent records to retrieve
     * @return a list of the most recent PatientRecord objects
     */
    public List&lt;PatientRecord&gt; getRecentRecords(int patientId, int count) {
<span class="nc" id="L197">        List&lt;PatientRecord&gt; recentRecords = recentRecordsCache.get(patientId);</span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">        if (recentRecords == null || recentRecords.isEmpty()) {</span>
<span class="nc" id="L199">            return new ArrayList&lt;&gt;();</span>
        }

<span class="nc" id="L202">        ReadWriteLock lock = patientLocks.get(patientId);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (lock == null) {</span>
<span class="nc" id="L204">            return new ArrayList&lt;&gt;();</span>
        }

<span class="nc" id="L207">        lock.readLock().lock();</span>
        try {
<span class="nc" id="L209">            int size = recentRecords.size();</span>
<span class="nc" id="L210">            int startIndex = Math.max(0, size - count);</span>
<span class="nc" id="L211">            return new ArrayList&lt;&gt;(recentRecords.subList(startIndex, size));</span>
        } finally {
<span class="nc" id="L213">            lock.readLock().unlock();</span>
        }
    }

    /**
     * Retrieves a collection of all patients stored in the data storage.
     *
     * @return a list of all patients
     */
    public List&lt;Patient&gt; getAllPatients() {
<span class="fc" id="L223">        return new ArrayList&lt;&gt;(patientMap.values());</span>
    }

    /**
     * Retrieves a patient by their ID.
     *
     * @param patientId the unique identifier of the patient
     * @return the patient object, or null if not found
     */
    public Patient getPatient(int patientId) {
<span class="fc" id="L233">        return patientMap.get(patientId);</span>
    }

    /**
     * Gets the total number of records processed since the system started.
     * Useful for monitoring real-time data ingestion performance.
     *
     * @return the total number of records processed
     */
    public long getTotalRecordsProcessed() {
<span class="nc" id="L243">        return totalRecordsProcessed.get();</span>
    }

    /**
     * Gets the number of unique patients currently in the system.
     *
     * @return the number of patients
     */
    public int getPatientCount() {
<span class="nc" id="L252">        return patientMap.size();</span>
    }

    /**
     * Clears all patient data from the storage.
     * This method should be used with caution and primarily for testing purposes.
     */
    public synchronized void clearAllData() {
<span class="nc" id="L260">        patientMap.clear();</span>
<span class="nc" id="L261">        patientLocks.clear();</span>
<span class="nc" id="L262">        recentRecordsCache.clear();</span>
<span class="nc" id="L263">        totalRecordsProcessed.set(0);</span>
<span class="nc" id="L264">        System.out.println(&quot;All patient data cleared from storage&quot;);</span>
<span class="nc" id="L265">    }</span>

    /**
     * Provides real-time statistics about the data storage system.
     *
     * @return a formatted string with system statistics
     */
    public String getSystemStatistics() {
<span class="nc" id="L273">        return String.format(&quot;DataStorage Statistics:\n&quot; +</span>
                           &quot;- Total Patients: %d\n&quot; +
                           &quot;- Total Records Processed: %d\n&quot; +
                           &quot;- Average Records per Patient: %.2f&quot;,
<span class="nc" id="L277">                           getPatientCount(),</span>
<span class="nc" id="L278">                           getTotalRecordsProcessed(),</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                           getPatientCount() &gt; 0 ? (double) getTotalRecordsProcessed() / getPatientCount() : 0.0);</span>
    }

    /**
     * The main method for the DataStorage class.
     * Initializes the system, reads data into storage, and continuously monitors
     * and evaluates patient data.
     * 
     * @param args command line arguments
     */
    public static void main(String[] args) {
        // DataReader is not defined in this scope, should be initialized appropriately.
        // DataReader reader = new SomeDataReaderImplementation(&quot;path/to/data&quot;);
<span class="fc" id="L292">        DataStorage storage = new DataStorage();</span>

        // Assuming the reader has been properly initialized and can read data into the
        // storage
        // reader.readData(storage);

        // Example of using DataStorage to retrieve and print records for a patient
<span class="fc" id="L299">        List&lt;PatientRecord&gt; records = storage.getRecords(1, 1700000000000L, 1800000000000L);</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        for (PatientRecord record : records) {</span>
<span class="nc" id="L301">            System.out.println(&quot;Record for Patient ID: &quot; + record.getPatientId() +</span>
<span class="nc" id="L302">                    &quot;, Type: &quot; + record.getRecordType() +</span>
<span class="nc" id="L303">                    &quot;, Data: &quot; + record.getMeasurementValue() +</span>
<span class="nc" id="L304">                    &quot;, Timestamp: &quot; + record.getTimestamp());</span>
<span class="nc" id="L305">        }</span>

        // Initialize the AlertGenerator with the storage
<span class="fc" id="L308">        AlertGenerator alertGenerator = new AlertGenerator(storage);</span>

        // Evaluate all patients' data to check for conditions that may trigger alerts
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        for (Patient patient : storage.getAllPatients()) {</span>
<span class="nc" id="L312">            alertGenerator.evaluateData(patient);</span>
<span class="nc" id="L313">        }</span>
<span class="fc" id="L314">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>